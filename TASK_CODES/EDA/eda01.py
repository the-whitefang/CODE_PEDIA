# -*- coding: utf-8 -*-
"""EDA01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1u_6j0d67GsUFJ9qJsQ6JqIrOpCs9Bjiq
"""

import pandas as pd
import matplotlib.pyplot as plt
import re

df = pd.read_csv('checklist_data_202505220954.csv')
data = pd.DataFrame(df)
data.head()

data.columns

data.info()

data.describe().T

data.isnull().sum()

data.duplicated()

file_name = data['filename'].to_list()

file_name

names = []
for f in file_name:
    match = re.search(r'PAM(?:_(?:SENP|DOE))?_([^.]+(?:\.[^_]+)?)_', f)
    if match:
        names.append(match.group(1))
    else:
        names.append(None)


# Display the names
for name in names:
    print(name)

data['subDisposition']

subDisposition_list = []
subDisposition_list = data['subDisposition'].unique()
for i in range(0,9999):
  print(subDisposition_list)

subDisposition_count_dict = data['subDisposition'].value_counts().to_dict()
subDisposition_count_dict

x = list(subDisposition_count_dict.keys())

y = list(subDisposition_count_dict.values())

plt.figure(figsize=(25, 10))
plt.bar(x, y, color='skyblue')

plt.title("Total count of SubDisposition Category")
plt.xlabel("Categories")
plt.ylabel("Values")
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

employee_id_dict = data['empID'].value_counts().to_dict()
employee_id_dict # from this we can find the total number of calls made
#by each employeee.

employee_list = data['empID'].unique().tolist()

data['callDate'] = data['callDate'].astype(str)

date_list = data['callDate'].apply(lambda x: x.split()[0]).tolist()
time_list = data['callDate'].apply(lambda x: x.split()[1]).tolist()

print("Dates:", date_list)
print("Times:", time_list)

data['callDate'] = data['callDate'].astype(str)
data['callHour'] = data['callDate'].apply(lambda x: int(x.split()[1].split(':')[0]))

# Create the time slot string like '9-10', '10-11', etc.
data['hourSlot'] = data['callHour'].apply(lambda h: f"{h}-{h+1}")

# Count number of calls per hour slot
calls_per_hour = data.groupby('hourSlot').size().to_dict()

print(f"Calls per Hour = \n {calls_per_hour}")

#from this we can find out the total
data['callDate'] = data['callDate'].astype(str)
data['callHour'] = data['callDate'].apply(lambda x: int(x.split()[1].split(':')[0]))

# Create hour slots like "9-10"
data['hourSlot'] = data['callHour'].apply(lambda h: f"{h}-{h+1}")

# Group by 'empID' and 'hourSlot', then count calls
grouped = data.groupby(['empID', 'hourSlot']).size()

# Convert to nested dictionary: {empID: {hourSlot: call_count}}
emp_hour_calls = {}
for (emp, hour), count in grouped.items():
    emp_hour_calls.setdefault(emp, {})[hour] = count

# Optional: print a sample
from pprint import pprint
pprint(emp_hour_calls)

not_interested_count = data[data['dispositionType'] == 'NOT INTERESTED'].shape[0]
not_interested_count

data.columns

total_calls = data['subProcess'].shape[0]
total_calls

subProcess_SENP = data[data['subProcess'] == 'SENP'].shape[0]
print(f"Total Calls made from the 'SENP' subProcess: {subProcess_SENP}")
subprocess_SENP_SALE_count = data[ (data['subProcess'] == 'SENP') & (data['dispositionType'] == 'SALE')].shape[0]
print(f"Total Calls that ended up wit 'SALE' under the subProcess of SENP: {subprocess_SENP_SALE_count}")
subprocess_SENP_SALE_percentage = (subprocess_SENP_SALE_count/subProcess_SENP)*100.0
percentage_of_calls_under_senp = round(((subProcess_SENP/total_calls)*100.0), 2)
print(f"Percentage of calls made under the SENP Channel: {percentage_of_calls_under_senp}%")
print(f"Percentage of calls that ended up with 'SALE' under the subProcess: {round(subprocess_SENP_SALE_percentage, 2)}%")

subProcess_DOE = data[data['subProcess'] == 'DOE'].shape[0]
print(f"Total calls made from the 'DOE' subProcess: {subProcess_DOE}")
subProcess_DOE_SALE_count = data[(data['subProcess'] == 'DOE') & (data['dispositionType'] == 'SALE')].shape[0]
print(f"Total Calls that ended up with 'SALE' under the DOE subProcess:  {subProcess_DOE_SALE_count}")
subProcess_DOE_SALE_percentage = round(((subProcess_DOE_SALE_count/subProcess_DOE)*100.0), 2)
percentage_of_calls_under_doe = round(((subProcess_DOE/total_calls)*100.0), 2)
print(f"Percentage of calls made under the DOE Channel: {percentage_of_calls_under_doe}%")
print(f"Percentage of Calls that ended up with 'SALE' under the subProcess DOE: {subProcess_DOE_SALE_percentage}%")

filtered_df = df[(df['subProcess'] == 'SENP') & (df['dispositionType'] == 'SALE')]

# Select the relevant columns for analysis
columns_of_interest = [
    'profileDetails__companyName',
    'profileDetails__netSalary',
    'profileDetails__existingObligations',
    'profileDetails__dob',
    'profileDetails__experienceYears',
    'profileDetails__designation',
    'btBankDetails__btBankName',
    'btBankDetails__sanctionLoanAmount',
    'btBankDetails__btPOS',
    'btBankDetails__existingbtIrr',
    'btBankDetails__currentHlEMI',
    'btBankDetails__pOSTenor',
    'propertyDetails__propertyType',
    'propertyDetails__propertyValueAsPerCustomer',
    'propertyDetails__location',
    'propertyDetails__propertyPincode',
    'propertyDetails__areaSquareFeet'
]

filtered_data = filtered_df[columns_of_interest]

# Display a summary of the filtered data
filtered_data.describe(include='all')

emp_ID = data['empID'].value_counts().to_dict()
emp_ID.items()

data['callDate'] = pd.to_datetime(data['callDate'], format= '%d-%m-%Y %H:%M', errors='coerce')

data['callTime'] = data['callDate'].dt.time

data['callOnlyDate'] = data['callDate'].dt.date

data['callTime']

data.groupby(['dispositionType']).size()

data.groupby(['subDisposition']).size()['NO_REQUIREMENT']

good_greetings = data[(data['opening__opening'] =='Yes') & (data['closing__closing'] == 'Yes')
    & (data['subDisposition'] == 'SALE_DONE')]['empID'].unique().shape[0]

print(f"Number of employees that do proper opening and closing greeting to the customer: {good_greetings}")

max_sale_tenure_5 = data[((data['empTenure'] == 5)  | (data['empTenure'] == 1)) & (data['subDisposition'] == 'SALE_DONE')]
print(f"Number of calls made when the tenure period is wither 5 or 1: { max_sale_tenure_5.shape[0]}")

tenure_dict = data['empTenure'].value_counts().to_dict()
tenure_dict

autodispose_calls_doe = data[ (data['subProcess'] == 'DOE') & (data['subDisposition'] == 'AUTODISPOSE') ].shape[0]
percentage_of_autodispose_calls = round(((autodispose_calls_doe/total_calls)*100.0), 2)
print(f"Percentage of AUTODISPOSE Calls: {percentage_of_autodispose_calls}%")

calls_per_hour = data['callHour'].value_counts().sort_index()

peak_hour = calls_per_hour.idxmax()
max_calls = calls_per_hour.max()


print("Calls per hour:")
print(calls_per_hour)
print(f"\nPeak call hour: {peak_hour}:00 with {max_calls} calls")

plt.figure(figsize=(12, 6))
bars = plt.bar(calls_per_hour.index, calls_per_hour.values, color='skyblue')


for bar in bars:
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, height + 10,
             str(int(height)), ha='center', va='bottom', fontsize=10)


plt.xlabel('Hour of the Day (24-hour format)')
plt.ylabel('Number of Calls')
plt.title('Number of Calls per Hour')
plt.xticks(range(0, 24))
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

calls_per_employee = df['empID'].value_counts().reset_index()

# Rename columns for clarity
calls_per_employee.columns = ['empID', 'callCount']

# Sort by callCount descending (this is actually already sorted by value_counts())
calls_per_employee = calls_per_employee.sort_values(by='callCount', ascending=False)

# Display the table
print(calls_per_employee.head(10))

sale_done_df = data[data['subDisposition'] == 'SALE_DONE']


sales_by_employee = sale_done_df['empID'].value_counts().reset_index()

sales_by_employee.columns = ['empID', 'saleDoneCalls']


sales_by_employee = sales_by_employee.sort_values(by='saleDoneCalls', ascending=False)


print(sales_by_employee)

sale_done = data[data['subDisposition'] == 'SALE_DONE']


calls_by_emp = sale_done['empID'].value_counts()

TOP_N = 20
calls_by_emp = calls_by_emp.head(TOP_N)

plt.figure(figsize=(14, 6))
bars = plt.bar(calls_by_emp.index, calls_by_emp.values)

for bar in bars:
    h = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, h + 0.5,
             f'{int(h)}', ha='center', va='bottom', fontsize=8)

plt.xlabel('Employee ID')
plt.ylabel('Number of SALE_DONE Calls')
plt.title('Top Employees by Successful (SALE_DONE) Calls')
plt.xticks(rotation=45, ha='right')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

filtered_callback = data[data['subDisposition'] == 'CALL_BACK'].shape[0]
percentage_of_callback_calls  = round(((filtered_callback/total_calls)*100.0), 2)
print(f"Percentage of customers that made a Call Back: {percentage_of_callback_calls}%")

appointment_time_count_no = data[data['offerDetails__appointmentTime'] == 'No' ].shape[0]
percentage_of_appointmentTime_no = round(((appointment_time_count_no/total_calls)*100.0), 2)
print(f"Percentage of calls that had the APPOINTMENT TIME as NO: {percentage_of_appointmentTime_no}%")

appointment_time_count_yes = data[data['offerDetails__appointmentTime'] == 'Yes' ].shape[0]
percentage_of_appointmentTime_yes = round(((appointment_time_count_yes/total_calls)*100.0), 2)
print(f"Percentage of calls that had the APPOINTMENT TIME as YES: {percentage_of_appointmentTime_yes}%")

calls_ended_with_closing_no = data[data['closing__closing'] == 'No'].shape[0]
percentage_of_calls_closing_as_no = round(((calls_ended_with_closing_no/total_calls)*100.0), 2)
print(f"Percentage of calls that remains unclosed: {percentage_of_calls_closing_as_no}%")
print(f"Percentage of calls that did got closed by the agents: {100.00-percentage_of_calls_closing_as_no}%")